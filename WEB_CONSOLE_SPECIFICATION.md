# Техническое задание: Веб-консоль для Service Booking

## 1. Общая концепция

**Веб-консоль** — это единая платформа для управления сервисом записи клиентов. Она объединяет:
- **Серверную часть (Backend)** — весь бэкенд и бизнес-логика находятся в веб-консоли
- **Административный интерфейс** — веб-приложение для управления услугами, записями, клиентами и настройками
- **REST API** — интерфейс для мобильного iOS-приложения

**iOS-приложение** — клиентское приложение, которое:
- Не хранит данные локально (вся информация с сервера)
- Подключается к API веб-консоли по QR-коду при первом запуске
- Отображает услуги, создаёт/отменяет записи, показывает профиль клиента

---

## 2. Архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│                     ВЕБ-КОНСОЛЬ (единая система)                 │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────┐    ┌──────────────────────────────┐   │
│  │  Админ-панель (Web)  │    │  REST API (Backend)          │   │
│  │  - Управление        │◄──►│  - База данных               │   │
│  │  - Услуги, записи    │    │  - Бизнес-логика             │   │
│  │  - Клиенты           │    │  - Авторизация               │   │
│  │  - QR для подключения│    │  - Все эндпоинты             │   │
│  └──────────────────────┘    └──────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                        ▲
                                        │ HTTPS / JSON
                                        │
                               ┌────────┴────────┐
                               │  iOS-приложение │
                               │  (клиент)       │
                               └─────────────────┘
```

**Ключевое требование:** серверная часть (API, база данных, логика) является частью веб-консоли. Отдельного backend-проекта нет.

---

## 3. Подключение iOS-приложения (QR-код)

### 3.1 Генерация QR-кода в веб-консоли

В настройках веб-консоли должен быть раздел **«Подключение мобильного приложения»** с QR-кодом.

QR-код может содержать один из форматов:

**Вариант 1 — JSON:**
```json
{
  "base_url": "https://your-domain.com/api/v1",
  "token": "опциональный_токен_клиента"
}
```

**Вариант 2 — URL:**
```
https://your-domain.com/api/v1
```

**Вариант 3 — Custom scheme:**
```
servicebooking://config?url=https://your-domain.com/api/v1&token=опционально
```

### 3.2 Регистрация клиента и уникальный API-ключ

При сканировании QR **без токена** (просто URL) iOS-приложение автоматически регистрирует устройство в веб-консоли:

1. Приложение генерирует `device_id` (UUID) при первом запуске и хранит в Keychain
2. Приложение отправляет POST-запрос на `/clients/register`
3. Сервер создаёт нового клиента, привязывает к нему уникальный API-ключ
4. Возвращает `client_id` и `api_key`
5. Приложение сохраняет `api_key` и `client_id` в Keychain (никогда в UserDefaults)
6. Все последующие запросы используют заголовок `Authorization: Bearer <api_key>`

**Безопасность:** `device_id`, `api_key`, `client_id` хранятся в Keychain (iOS Security framework).

### 3.3 Что должно быть в настройках

- Базовый URL API (например, `https://api.example.com/v1`)
- Кнопка «Показать QR для подключения» (QR содержит только URL)
- Инструкция для пользователя приложения
- Эндпоинт регистрации `/clients/register` (см. раздел 5.5)

---

## 4. REST API — требования для iOS

**Базовый URL:** `https://your-domain.com/api/v1` (или аналогичный)

**Формат:** JSON, кодировка UTF-8  
**Даты:** ISO 8601 (например, `2025-01-31T14:30:00Z`)  
**Ключи в JSON:** snake_case (`service_id`, `created_at`, `base_url` и т.д.)

### 4.1 Авторизация

- Заголовок: `Authorization: Bearer <api_key>`
- API-ключ получается при регистрации устройства (POST `/clients/register`) или из QR (если админ заранее создал клиента)
- Код ответа 401 — «Необходима авторизация»

---

## 5. Эндпоинты API

### 5.0 Регистрация клиента

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| POST | `/clients/register` | Регистрация устройства, получение уникального API-ключа |

**Запрос (тело):**
```json
{
  "device_id": "UUID-устройства",
  "platform": "iOS 17.0",
  "app_version": "1.0"
}
```

**Ответ (200):**
```json
{
  "client_id": "string",
  "api_key": "string"
}
```

- Сервер создаёт или находит клиента по `device_id`
- Возвращает уникальный `api_key` для последующих запросов
- При повторной регистрации того же `device_id` — можно вернуть существующий ключ или создать новый (на усмотрение веб-консоли)

---

### 5.1 Услуги

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/services` | Список всех активных услуг |
| GET | `/services/:id` | Детали услуги по ID |

**Модель Service (ответ):**
```json
{
  "_id": "string",
  "name": "string",
  "description": "string",
  "price": 0.0,
  "duration": 60,
  "category": "string",
  "image_url": "string или null",
  "is_active": true
}
```

- `duration` — длительность в минутах
- `is_active: false` — услуга не показывается в приложении

---

### 5.2 Записи (Bookings)

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/bookings` | Список записей текущего пользователя |
| POST | `/bookings` | Создать запись |
| DELETE | `/bookings/:id` | Отменить запись |

**Модель Booking (ответ):**
```json
{
  "_id": "string",
  "service_id": "string",
  "service_name": "string",
  "user_id": "string",
  "date_time": "2025-01-31T14:30:00Z",
  "status": "pending",
  "price": 0.0,
  "duration": 60,
  "notes": "string или null",
  "created_at": "2025-01-31T12:00:00Z",
  "in_progress_started_at": "2025-01-31T14:35:00Z или null"
}
```

**Статусы:** `pending`, `confirmed`, `in_progress`, `completed`, `cancelled`

- **in_progress_started_at** (опционально) — дата/время в ISO 8601, когда администратор перевёл запись в статус «В процессе». Если поле присутствует, iOS использует его для точного таймера в виджете (Live Activity) при автозапуске. Рекомендуется при смене статуса на `in_progress` сохранять текущее время в это поле.

**Запрос создания (POST /bookings):**
```json
{
  "service_id": "string",
  "date_time": "2025-01-31T14:30:00Z",
  "post_id": "post_1",
  "notes": "string или null"
}
```

---

### 5.3 Посты (боксы автомойки)

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/posts` | Список постов (боксов) |

**Ответ (массив):**
```json
[
  {
    "_id": "post_1",
    "name": "Пост 1",
    "is_enabled": true,
    "use_custom_hours": false,
    "start_time": "09:00",
    "end_time": "18:00",
    "interval_minutes": 30
  }
]
```

- `is_enabled: true` — пост доступен для бронирования
- По умолчанию iOS использует `post_1`, при наличии нескольких постов — выбор в UI

---

### 5.4 Слоты времени

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/slots?service_id=:id&date=:date&post_id=:post` | Свободные слоты на дату и пост |

**Параметры:**
- `service_id` — ID услуги
- `date` — дата YYYY-MM-DD (например `2026-02-01`)
- `post_id` — ID поста (по умолчанию `post_1`)

**Ответ (массив):**
```json
[
  {
    "time": "2026-02-01T09:00:00.000Z",
    "is_available": true
  },
  {
    "time": "2026-02-01T09:30:00.000Z",
    "is_available": false
  }
]
```

- Время в UTC (ISO 8601), iOS конвертирует в локальную зону
- Показывать только слоты с `is_available: true`

---

### 5.5 Профиль пользователя

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/profile` | Профиль текущего пользователя |
| PUT | `/profile` | Обновить профиль |

**Модель User (ответ):**
```json
{
  "_id": "string",
  "first_name": "string",
  "last_name": "string",
  "phone": "string",
  "email": "string или null",
  "avatar_url": "string или null",
  "social_links": {
    "telegram": "string или null",
    "whatsapp": "string или null",
    "instagram": "string или null",
    "vk": "string или null"
  },
  "created_at": "2025-01-31T12:00:00Z"
}
```

**Запрос обновления (PUT /profile):**
```json
{
  "first_name": "string или null",
  "last_name": "string или null",
  "email": "string или null",
  "social_links": {
    "telegram": "string или null",
    "whatsapp": "string или null",
    "instagram": "string или null",
    "vk": "string или null"
  }
}
```

---

### 5.6 Уведомления (сообщения от веб-консоли)

Сообщения от сервиса и администратора отображаются в iOS-приложении в разделе **«Сообщения»**. Клиент получает их тем же способом, что и данные об услугах и записях — через API.

| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/notifications` | Список уведомлений текущего клиента (сервисные + от администратора) |
| PATCH | `/notifications/:id/read` | Отметить уведомление как прочитанное (опционально) |

**Ответ GET /notifications (массив):**
```json
[
  {
    "_id": "string",
    "body": "Текст сообщения",
    "created_at": "2026-02-01T14:30:00Z",
    "type": "service",
    "title": "Заголовок или null",
    "read": false
  },
  {
    "_id": "string",
    "body": "Ваш авто готов. Можете забирать ключи.",
    "created_at": "2026-02-01T15:00:00Z",
    "type": "admin",
    "title": "Услуга завершена",
    "read": false
  }
]
```

- **type:** `"service"` — сервисное уведомление (напоминания, подтверждения записи и т.д.), `"admin"` — сообщение от администратора.
- **title** — опциональный заголовок (например, «Напоминание о записи», «Услуга завершена»).
- **body** — основной текст сообщения.
- **read** — прочитано ли клиентом (для PATCH при открытии сообщения в приложении).

**Требования к веб-консоли:**

1. **Хранение уведомлений** — в БД веб-консоли должна быть сущность «уведомление» с полями: `_id`, `client_id` (или `user_id`), `body`, `created_at`, `type` (`service` | `admin`), `title` (опционально), `read` (по умолчанию `false`).
2. **Отправка от администратора** — в админ-панели должен быть способ отправить сообщение клиенту (например, в карточке клиента или записи кнопка «Отправить сообщение»). При отправке создаётся запись в таблице уведомлений с `type: "admin"`.
3. **Сервисные уведомления** — создаются автоматически при событиях (подтверждение записи, напоминание за N часов, «Ваш авто готов» после смены статуса на «Завершена» и т.д.) с `type: "service"`.
4. **GET /notifications** — возвращает только уведомления текущего клиента (по `Authorization: Bearer <api_key>` определяется клиент).
5. **PATCH /notifications/:id/read** — помечает уведомление как прочитанное; тело запроса может быть пустым или `{"read": true}`.

iOS-приложение при открытии раздела «Сообщения» запрашивает GET `/notifications`, при pull-to-refresh — повторяет запрос. Сообщения отображаются с подписью «Сервис» или «Администратор» и опциональным заголовком.

---

## 6. Функции веб-консоли (админ-панель)

### 6.1 Управление услугами

- Список услуг (таблица/карточки)
- Добавление услуги: название, описание, цена, длительность, категория, изображение, активна/неактивна
- Редактирование и удаление услуг
- Группировка по категориям

### 6.2 Управление записями

- Список всех записей
- Фильтры: по дате, услуге, статусу, клиенту
- **Смена статуса** (ожидает → подтверждена → **в процессе** → завершена)
  - При переводе записи в **«В процессе»** сохранять текущее время в поле `in_progress_started_at` (и возвращать его в GET `/bookings`). Это обеспечивает корректный таймер в виджете на устройстве клиента при автозапуске.
- Отмена записи
- Просмотр деталей записи

### 6.3 Управление клиентами

- Список клиентов
- Профиль клиента: ФИО, телефон, email, соцсети
- История записей клиента

### 6.4 Календарь и слоты

- Настройка рабочих часов
- Управление доступностью слотов (например, блокировка времени)
- Генерация слотов на основе длительности услуг и занятости

### 6.5 Настройки и QR-код

- Базовый URL API
- Генерация QR-кода для подключения iOS-приложения
- Выдача токенов клиентам (если используется авторизация)

### 6.6 Уведомления и сообщения клиентам

- **Список уведомлений** по клиенту (в карточке клиента или отдельный раздел).
- **Отправка сообщения от администратора** — форма: выбор клиента (или из карточки записи/клиента), текст сообщения, опционально заголовок. Сохранение создаёт запись с `type: "admin"`; клиент видит её в приложении в разделе «Сообщения».
- **Сервисные уведомления** — создавать автоматически при:
  - подтверждении записи (админ выбрал «Подтверждена»);
  - напоминании о записи (за N часов до времени);
  - смене статуса на «Завершена» (например: «Ваш авто готов. Администратор подтвердил завершение.»).
- Все уведомления доставляются клиенту через GET `/notifications` (приложение запрашивает при открытии раздела «Сообщения» и при обновлении).

### 6.7 (Опционально) Аналитика

- Статистика записей
- Популярные услуги
- Загрузка по дням/неделям

---

## 7. Технические требования к API

- **Протокол:** HTTPS (обязательно для production)
- **CORS:** разрешить запросы с мобильных клиентов
- **Таймаут:** рекомендуемый timeout запроса — 30 секунд
- **Кэширование:** iOS-приложение отправляет `Cache-Control: no-cache` — сервер не должен принудительно кэшировать ответы
- **Кодировка:** UTF-8
- **Ошибки:** при 4xx/5xx возвращать JSON с описанием ошибки

---

## 8. Сценарии использования

### Сценарий 1: Админ добавляет услугу

1. Админ в веб-консоли создаёт услугу «Химчистка салона».
2. Услуга сохраняется в БД и становится доступна через API.
3. Клиент открывает iOS-приложение → услуга отображается в списке.
4. Клиент может записаться на неё.

### Сценарий 2: Клиент записывается на услугу

1. Клиент выбирает услугу в приложении.
2. Приложение запрашивает `/slots?service_id=...&date=...`.
3. Клиент выбирает слот и нажимает «Записаться».
4. Приложение отправляет POST `/bookings`.
5. В веб-консоли появляется новая запись.
6. Админ может подтвердить или отменить её.

### Сценарий 3: Подключение приложения по QR

1. Админ в настройках открывает раздел «Подключение приложения».
2. Генерируется QR-код с URL API (и при необходимости токеном).
3. Клиент при первом запуске сканирует QR.
4. Приложение сохраняет URL и токен и подключается к API.

### Сценарий 4: Автозапуск виджета (Live Activity) при подтверждении «В процессе»

1. У клиента есть запись в статусе «Подтверждена».
2. Администратор в веб-консоли переводит запись в статус **«В процессе»** (нажатием кнопки).
3. При смене статуса веб-консоль сохраняет текущее время в поле `in_progress_started_at` для этой записи.
4. Когда клиент открывает iOS-приложение (или обновляет список записей), приложение получает GET `/bookings` и видит запись со статусом `in_progress`.
5. **Запуск виджета полностью автоматический:** приложение без участия пользователя запускает Live Activity (виджет в Dynamic Island и на экране блокировки). Клиенту не нужно ничего нажимать.
6. В виджете отображаются название услуги, прогресс и оставшееся время (по `in_progress_started_at` и длительности услуги). После истечения времени виджет показывает «Ваш авто готов»; запись администратор переводит в «Завершена» в консоли.

---

## 9. Резюме для разработчика

1. **Серверная часть — внутри веб-консоли.** Отдельный backend-проект не предполагается.
2. **REST API** должно точно соответствовать структуре JSON и эндпоинтам выше.
3. **Веб-интерфейс** — для управления услугами, записями, клиентами и настройками (в т.ч. QR).
4. **QR-код** — для подключения iOS-приложения к конкретному экземпляру API.
5. **Даты** — везде в формате ISO 8601.
6. **Ключи JSON** — в snake_case.

При необходимости можно запросить у iOS-разработчика примеры запросов/ответов или дополнительные поля в моделях.
